Reversing.kr中的Adventure，怕是这里面最硬核的题了，因为最少人做出来。不过这主要是很多人不知道appx文件如何动态调试。

# 解题过程

## 程序安装

1. 需要将系统时间修改至证书时间，否则会有错误0x800B0101。
2. 安装前需要先安装证书
   1. 右键点击appx文件，选择“属性”->“数字签名”
   2. 点击“详细信息”，然后点击“查看证书”
   3. 选择“安装证书”->"本地计算机"->“将所有证书放入下列存储”->"受信任的根证书颁发机构"。
3. 安装前先安装dependency中的x86下文件，否则会说有冲突组件或不支持。

## 调试配置

1. plm程序调试可以使用plmdebug.exe。这个是微软提供的调试工具，专门用于调试appx文件，可以通过winSDK获得。

2. 使用命令行将程序与调试器绑定。

   ```plmdebug.exe /enableDebug <package> <调试器路径>```

   其中，package是plm程序的包名，一般与程序名称长很多，可以通过```plmdebug /query```查询，包名一般带有程序名称，所以比较好找。

   这里我使用的是一个叫x32dbg的调试器，因为OD调试时出现了不可解决的异常。

3. 将appx解压后可以得到一个exe文件，这个就是核心的二进制程序。虽然这个程序不可以运行，但可以用来分析逻辑。

## 分析

1. 运行程序，查看字符串，发现了两个明显的字符串“Flag1”和“Flag2”。追踪到对应位置，然后根据offset在IDA中查看反编译源码。

   这两个字符串出现在sub_403890中。经调试可以发现，这个函数就是打怪、计算flag、输出flag的关键函数。

   1. 打怪判断位置如下

      403be3-403c24为击中判断，首先判断有没有子弹，然后判断子弹位置与devil位置是否相同，如果同则jmp 3c8e。

      ![图1 击中判断](Snipaste_2019-07-30_09-36-12.PNG)

   2. flag输出位置如下

      一共有两个，打怪分数达到0xddb会输出flag1，打怪分数达到0x31159cd会输出flag2。

      ![图2 flag1](Snipaste_2019-07-30_09-38-05.PNG)

      ![图3 flag2](Snipaste_2019-07-30_09-39-03.PNG)

   3. 然后查找flag变量的引用就可以找到flag计算的位置。一共有两个：

      ![图4 flag计算1](Snipaste_2019-07-30_09-39-40.PNG)

      其中，v15 = *v9，v25 = v85，v4就是a1。很明显，这是一个面向对象开发的程序，小结中会说到。

      ![图5 flag计算2](Snipaste_2019-07-30_09-57-19.PNG)

      这个计算“隐藏”的很深，稍不留神就看不到了。其中，查看虚表可知v4 + 32是一个循环移位函数，相当于rol4(a2, a3)；v87 = *v9。所以这段代码翻译如下：

      ```c
       int i = (unsigned __int8)(signed int)*v9;
       v4[2 * i + 34] = rol4(v4[2 * i + 34], i);//rol4就是将被移位参数看做4个字节的无符号整数
       v4[2 * i + 35] = rol4( v4[2 * i + 35], (unsigned __int8)(*(int *)(v9+1));
      ```

2. 将打怪击中判断直接爆破掉，然后程序就可以自己运行出flag。

   经实践，得到第一个flag大概需要1h；经计算，得到第二个flag大概需要595天，所以还是要看懂程序逻辑，自行恢复出flag生成算法。

   另外，flag是显示在score的位置，需要先下好断点，否则会被后续分数覆盖掉。

3. 本来以为可以修改怪物释放时间，但是发现不可以粗暴的修改4043a0函数，因为之后的字符串异或需要用到rand

# 小结

这个程序是面向对象开发的程序，在引用成员函数和成员变量时都是使用对象基址+偏移地址。

本程序还使用了很多虚函数，而虚函数地址都存在虚表中，那么在使用IDA分析时如何找到虚表？

1. 先找到一个函数(sub_xxx)
2. 通过动态调试的方法找到它的一个引用地址(yyy)
3. 在IDA中查找yyy对应的伪代码(a1+zzz)，这个a1就是虚表的起始地址。
4. 在IDA查找sub_xxx的存储地址(ooo)，这个地址就是(a1+zzz)的实际值
5. 那么虚表基址即为ooo - zzz

其实，a1就是类对象的this指针指向的地址。之所以虚表基址与a1相同是因为虚表存储在对象所在内存空间的起始位置。

# 参考文章

* [错误代码0x800b0101解决办法](http://www.uqidong.com/wtjd/2767.html)
* [appx程序证书安装](http://blog.sina.com.cn/s/blog_5f2ed5cb0101ce3u.html)