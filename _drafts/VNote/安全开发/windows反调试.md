---
layout: post
title: "反调小结"
pubtime: 2019-09-15
updatetime: 2020-09-20
categories: SecurityProgram Reverse
tags: Windows c AntiReverse
---

之前学了《逆向工程核心原理》的反调原理，又做了一道reversing.kr的twist，然后就开始飘了，简直不要太蠢。现在老老实实把自己学到反调手段总结记录如下。

# 1 windows反调试

反调一共有两种思路

* 隐藏逻辑——将程序的关键逻辑隐藏在不容易被发现的位置，从而使程序的核心逻辑不被发现
    * 使用TLS、SEH等机制，将关键逻辑放在TLS回调函数或SEH异常处理函数中
* 对抗调试器——使调试器无法正常运行
    * 对抗调试器首先要检测调试器，分为直接检测调试器和间接检测调试环境。
        * 直接检测调试器就是通过查看是否有调试器进程存在、是否有调试器窗口存在等方法检查是否安装了调试器或是否运行了调试器
        * 间接检测调试环境就是通过检查PEB、检查堆等在调试状态和非调试状态下有不同值的进程信息来检测本进程是否运行在调试状态中

## 1.2 隐藏逻辑

### 1.2.1 tls

tls(thread local storage)即线程本地存储，是windows为解决一个进程中多个线程同时访问全局变量而提供的机制。

#### (1)tls的反调应用

* 原理
    * 在每次创建和结束线程时都会调用tls回调函数，主线程也不例外，而且会在执行EP前调用tls回调函数。而调试器往往默认暂停在EP处，因此tls中的核心代码或反调代码是不会被没有经验的分析人员发现的。

* 问题
    1. OD2.0支持在暂停在tls回调函数
    2. 如果使用了tls，PE文件中会多一个tls TABLE(如下图)，很容易被看到
    ![](_v_images/20200919210732532_22480.png =700x)

* 使用
    * 插入如下代码
    ```c++
    ////通知链接器PE文件要创建TLS目录
    #pragma comment(linker, "/INCLUDE:__tls_used")
    //回调函数
    void NTAPI TLS_CALLBACK(PVOID DllHandle, DWORD Reason, PVOID Reserved)
    {
        if( IsDebuggerPresent() )//在回调函数中添加调试检测代码
        {
            MessageBoxA(NULL, "Debugger Detected!", "TLS Callback", MB_OK);
            ExitProcess(1);
        }
    }
    //要在程序中使用TLS，首先为TLS数据单独建一个数据段，并用相关数据填充此段，通知链接器为TLS数据在PE文件头中添加数据。
    //链接器对于相似节采用字典顺序进行合并 ，也就是对位于节".CRT后的字符串进行排序。例如，位于节“.CRTXLB”中的变量将在位于节“.CRT XLA”中变量位置的后面，但是在位于节“.CRTXLZ”中的变量的前面。C运行时库利用编译器的这一特性来创建一个以NULL结尾的TLS回调数组，因此为了保证声明的函数指针位于TLS回调数组内部，必须将它放在节“.CRT XLZ”中放置一个NULL指针）。因此为了保证声明的函数指针位于TLS回调数组内部，必须将它放在节“.CRTXLx”中
    #pragma data_seg(".CRT$XLX")
    //为了使用CRT提供的TLS回调支持，需要我们声明一个PIMAGE_TLS_CALLBACK存放在以“.CRT$XLx“为名的节里面，这里x是一个位于A和Z之间的字母。
        PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = { TLS_CALLBACK, 0 };
    #pragma data_seg()
    ```
#### (2)tls的正常应用

当有一个变量，需要每个线程都有自己的一份存储，但又要求全局可见时就需要使用tls来存储这个变量。

* 使用场景
  * 全局计数器：每个线程维护自己的一个计数器存储，然后在计算总计数时将每个线程的全局计数器累加得到总的计数。
  * 日志：每个线程维护自己的日志，最终将每个线程的日志合起来得到完整的日志。
  * 内存分配器的本地缓存机制：每个线程都维持一个最近释放的内存缓冲池(全局可以访问)，这些内存被释放后并没有真的被内核回收，而是被线程标记为空闲，这样下次分配时，就可以直接从缓冲池中取，而不需要向内核申请也不需要进行线程同步。

* 原理
    * 静态tls：只需要在变量前加上`__declspec(thread)`关键字，编译器就会创建一个.tls节并将对应的变量放到.tls节中，然后链接程序会将来自所有对象模块的所有.tls节组合起来，形成结果的可执行文件或DLL文件中的一个大的完整的.tls节。当具有静态tls的程序加载到内存中时，系统会寻找可执行文件中的.tls节，并且动态地分配一个足够大的内存块，以便存放所有的静态TLS变量。应用程序中的代码每次引用其中的一个变量时，就要转换为已分配内存块中包含的一个内存位置。
        * 根据tls加载原理，可隐式链接有静态tls的dll，不可以显示链接有静态tls的dll
    * 动态tls：使用专门的函数动态的添加或删除tls变量。每一个线程拥有一个自己独立的TLS slot数组，用于存储tls变量，这个数组是全局可访问的。
        * TlsAlloc：对进程的位标志进行扫描，找到一个可用的位置，并返回该索引；如果找不到，就返回TLS_OUT_OF_INDEXES。*(事实上，除此之外，TlsAlloc函数还会自动清空所有线程的TLS数组的对应索引的值。这避免以前遗留的值可能引起的问题。)*
        * TlsSetValue：将对应的索引位保存一个特定的值
        * TlsGetValue：返回索引位的值。注意，这两个函数并不执行任何测试和错误检查，我们必须要保证索引是通过TlsAlloc正确分配的。
        * TlsFree：当所有线程都不需要保留TLS数组某个索引位的时候，应该调用TlsFree。该函数告知系统将进程的位标志数组的index位置为FREE状态。如果运行成功，函数返回TRUE。注意，如果试图释放一个没有分配的索引位，将产生一个错误。
* 回调函数
    * tls变量可以简单的交给操作系统维护，也可以由用户自己编写函数维护，这个函数就是经常被用来反调的回调函数。 

#### (3)参考文章
[1] [线程本地存储TLS(Thread Local Storage)的原理和实现——分类和原理](https://www.cnblogs.com/zhoug2020/p/6497709.html)
[2] [TLS （Thread Local Storage）反调试原理
](https://blog.csdn.net/bugmeout/article/details/45605497)

### 1.2.2 SEH

#### (1)反调应用

