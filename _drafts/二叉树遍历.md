二叉树是算法中常见的一种数据结构，最常见也是最关键的问题就是二叉树的遍历。

# 二叉树遍历

## 算法

二叉树的遍历分为两种：深度优先遍历(DFS)、广度优先遍历(BFS)。顾名思义，两种遍历的区别可理解为方向不同：深度优先是先纵向再横向、广度优先是先横向再纵向。

### 广度优先遍历

从根节点出发，先遍历同一层的节点，然后再遍历下一层的节点。如下图，编号顺序即为广度优先遍历的顺序。

![图](Snipaste_2020-02-20_11-25-09.png)

### 深度优先遍历

从根节点出发，先遍历一棵子树，再遍历另一棵子树。

![图](Snipaste_2020-02-20_11-26-28.png)

在遍历子树节点的时候，先向下遍历左节点直到最深的左节点，如果该节点有右子树，则按照这个方式遍历其右子树，否则回溯到父节点。如果父节点有右子树，则按照这个方式遍历其右子树，否再回溯到父节点的父节点。不断重复这个操作直到遍历完成。

![图](Snipaste_2020-02-20_11-38-38.png)

在遍历过程中，根据根节点的访问位置可以分为先序、中序、后序三种。三种顺序的遍历算法基本相同，仅有根节点的访问时机不同。无论哪种顺序，总是先访问左子树再访问右子树。

先序：首先访问根节点，然后遍历左子树，再遍历右子树。如图，首先访问根节点A，然后遍历其左子树。在遍历其左子树时，首先访问子树的根节点B，然后访问B的左子树。在访问B的左子树的时候，首先访问该树的根节点C，然后访问C的左子树(没有)，再访问C的右子树(仅有一个节点D)。然后回溯到B，遍历B的右子树(没有)；回溯到A，遍历A的右子树。同理遍历A的右子树。

![图](Snipaste_2020-02-20_11-46-38.png)

中序：先遍历左子树，再访问根节点，最后遍历右子树。

![图](Snipaste_2020-02-20_11-48-20.png)

后序：先遍历左子树，再遍历右子树，最后访问根节点。

![图](Snipaste_2020-02-20_11-49-29.png)

## 实现

节点结构：

```c++
template <class T>
class Node
{
private:
    Node *left;
    Node *right;
    T val;
    
public:
    Node(T val)
    {
        this->left = NULL;
        this->right = NULL;
        this->val = val;
    }
    Node();
    ~Node();
    
    T visit()
    {
       return this->val; 
    }
    
    Node* GetLeft()
    {
        return this->left;
    }
    
    Node* GetRight()
    {
        return this->right;
    }
    
}
    
typedef struct {
    Node *left;
    Node *right;
    T val;
}Node
```

### 广度优先

```c
void BreadthTraversal(Node *root)
{
    vector<Node*> vecNodes;
    vecNodes.push_back(root);
    vector<Node*>::iterator it;
    for(it = vecNodes.begin(); it != vecNodes.end(); it++)
    {
        it->visit();
        if(it->left != NULL)
            vecNodes.push_back(it->left);
        if(it->right != NULL)
            vecNodes.push_back(it->right);
    }  
}
```

### 深度优先

* 递归结构

  递归是解决二叉树问题最简单的办法。

```c++
//先序
void FirstDepthTraversal(Node *root)
{
    if(root == NULL)
        return;
    root->visit();
    FirstDepthTraversal(root->left);
    FirstDepthTraversal(root->right);
}
//中序
void MidDepthTraversal(Node *root)
{
    if(root == NULL)
        return;
    MidDepthTraversal(root->left);
    root->visit();
    MidDepthTraversal(root->right);
}
//后序
void LastDepthTraversal(Node *root)
{
    if(root == NULL)
        return;
    LastDepthTraversal(root->left);
    LastDepthTraversal(root->right);
    root->visit();
}
```

* 迭代结构

  递归简单，代码量也少，但是递归会占用调用栈的资源，当问题规模较大时会出现栈溢出。所以，为了稳定，缩小资源占有，缩短运行时间，最好使用迭代结构。

  二叉树的迭代又可以分为两种：一种通过栈模拟递归，一种利用空闲变量记录回溯信息。

  * 基于栈

    将路过但未访问过的节点压栈。

    ```c++
    //先序:一种思路是将所有的右节点压栈，然后再逐个取出来；一种是将根节点压栈，再取出来处理其右子树。本质上都是将回溯路径记录下来。
    void FirstDepthTraversal(Node *root)
    {
        vector<Node*> vecNodes;
        Node* curNode = root;
        while(curNode != NULL)
        {
            while(curNode != NULL)
            {
                curNode->visit();
                if(curNode->right != NULL)
                    vecNodes.push_back(curNode->right);            
                curNode = curNode->left;
            }
            if(!vecNodes.empty())
            {
               curNode = vecNodes.back();
            	vecNodes.pop_back(); 
            }
        }    
    }
    ```

  * Morris

    利用叶子节点的巧妙方法。

    ```c++
    //先序
    void FirstDepthTraversal(Node *root)
    {
        vector<int> ans;
        TreeNode *node = root;
        while(node)
        {
            if(node->left == NULL)
            {
                node->visit();
                node = node->right;
            }
            else
            {
                TreeNode *pre = node->left;
                while(pre->right != NULL && pre->right != node){
                    pre = pre->right;
                }
                if(pre->right == NULL){
                    pre->right = node;
                    node->visit();
                    node = node->left;
                }else{
                    pre->right = NULL;
                    node = node->right;
                }
    
            }
        }
    }
    ```


