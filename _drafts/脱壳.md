# 脱壳

## 1 壳的认知

1. 种类：按加壳效果分为压缩壳、加密壳、虚拟机壳。
2. 壳的数量繁多，还有层出不穷的新壳，不可能一一学习，关键还是原理：
   1. 加壳：加密或压缩原程序各个区段，然后增加新区段作为引导代码（脱壳代码），最后修改原程序入口点为引导代码入口点
   2. 脱壳：定位原程序代码区域，解密或解压原程序各个区段，修改程序入口点为原程序入口点


##  2 脱壳步骤

1. 找到OEP
2. 转储dump
3. 修复IAT

## 3 寻找OEP

* 一步直达

  * 做法：搜索jmp、call等跳转指令，**关键是跳转到第一区段地址的地方**。
  * 原理：解密完成后必然会有一个jmp或call指令使程序流程走向OEP。
  * 问题：解密代码本身就会有很多jmp和call，还有其他各种jmp，所以并不好判断哪个jmp是我们想要的；有些壳会对这部分代码进行保护，使OEP不被暴露。
* OD自带的定位功能
  * 做法：设置Options-Debugging options-SFX/调试-自解压功能选项，忽略全部异常，使用OD的自解压功能并暂停在OEP。
  * 问题：据说该选项只有在程序入口点在代码段之外才起作用（但我的在代码段也可以起作用）；据说使用这个设置无法分析正常程序，因为不会停在EP处（对，只是据说，因为我的又不会）
* 内存执行断点（较为有力）
  * 做法：将可能出现OEP的区段设置执行的内存断点，因此在程序跳转到OEP执行时会触发断点
  * 问题：区段不好找，有时需要一个一个的尝试
* 堆栈平衡法
  * 做法：在最初push的栈地址设置断点，结束后会需要pop该地址，也就是访问到该断点，从而会暂停程序
  * 原理：在栈中push操作占用的空间最终要pop出来，这样才不会栈溢出
  * 问题：现在很多壳都能检测这种方法；最初的push不一定在最后才pop，可能先pushpop然后再pushpop
* 最后一次异常
  * 做法：使用OD运行程序，忽略全部异常，然后点击L查看日志窗口，在最后一次异常发生处设置断点，再次运行程序，程序停在该处，此时对代码段设置内存执行断点。
  * 原理：有些壳使用异常处理来解密程序代码，则最后一次异常处理是最接近OEP的地方，在离OEP越近的地方设置内存访问断点,就越不容易被壳检测到
* 利用壳最常用的API函数来定位OEP
  * 做法：定位壳最常用的API函数,比如GetProcAddress,LoadLibrary等。设置条件断点查看被调用的情况，找出该函数最后一次被解密代码调用的地址，OEP在此附近。
  * 原理：壳在重塑原程序时需要重建IAT，所以会有一些正常程序不会大量使用但壳会大量使用的函数
* 利用应用程序调用的第一个API函数来定位OEP
  * 做法：在正常程序一般都会首先使用的API函数设置断点
  * 原理：易证
* TIPS:OEP往往在第一个区段，解密程序往往在其他区段，因此区分原程序运行的代码和解密程序运行的代码的关键就是地址是否在代码段中。