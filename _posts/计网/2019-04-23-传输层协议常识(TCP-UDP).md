---
layout: post
title: "传输层协议常识(TCP-UDP)"
pubtime: 2019-04-23
updatetime: 2019-06-03
categories: network LearningNote
tags: guide
---

传输层协议常识。

# 1 传输层协议

## 1.1 与网络层的关键区别

* 传输层协议与网络层协议的关键区别：面向的连接对象不同

  ![](https://chrishuppor.github.io/image/Snipaste_2020-04-23_15-10-47.png)

  * 其他区别
    * 协议不同
    * 传输层的提供差错校验，IP协议只校验首部
    * TCP协议可以提供可靠传输，IP协议只尽最大努力完成交付。

## 1.2 UDP和TCP对应应用层协议

![](https://chrishuppor.github.io/image/Snipaste_2020-04-23_15-15-04.png)

## 1.3 端口号

软件端口本质是一种16位的地址，用来通信进程在主机上的地址。

端口号分类：

* 服务端用的端口号

  服务端进程使用的端口，一般固定

  * 熟知端口（0-1023）

    ![](https://chrishuppor.github.io/image/Snipaste_2020-04-23_15-16-34.png)

  * 登记端口（1024-49151）

* 客户端用的端口号（49152-65535）

  * 客户进程运行时暂时使用的端口，用完就换，不固定

## 1.4 UDP

### 1.4.1 特点

（关键词：开销小，效率高，不可靠）

1. 无连接，尽最大努力交付——省去了连接的开销
2. 一次交付一个完整报文——不切割不合并报文，应用层的报文有多长，UDP照单全收。
3. 没有拥塞控制——效率高，不会因为网络拥塞而降低发送速率，适用于“允许少量数据丢失，不允许大时延”的情况。
4. 报文开销小——UDP首部仅8个字节

### 1.4.2 报文格式

![](https://chrishuppor.github.io/image/Snipaste_2020-05-13_14-52-03.png)

* 伪首部：简化的IP头，仅用于校验和计算，不上交不下传
* 首部：真正的UDP头部，8字节
  * 长度：整个UDP数据报的长度，最小为8字节（只有一个头）
  * 校验和：（伪首部+UDP首部+数据部分）的校验和。

## 1.5 TCP

### 1.5.1 特点

（关键词：可靠传输、流量控制、拥塞控制）

1. 面向**连接**——TCP通信双方要先建立连接再进行通信
2. **点对点**通信——每条TCP只能有两个端点，不支持多对多、多对一、一对多的通信
3. **可靠**交付——无差错、不丢失、不重复、按序到达（IP分组不按序到达）
4. **全双工**——接收方和发送方都有发送缓存和接收缓存，都可以收发数据
5. 面向**字节流**——将上层应用交付的数据全部看成字节流，不考虑数据的结构、含义、大小，TCP报文段中数据长度根据**对方的窗口大小**和**网络拥塞情况**来决定。

### 1.5.2 报文格式

![](https://chrishuppor.github.io/image/Snipaste_2020-05-22_16-01-51.png)

* **序号**：本报文段数据部分第一个字节对应的序号，即本报文数据部分第一个字节是整个数据的第几个字节（不是本报文段是第几个段）
  * TCP面向字节流，对每个字节都进行编号

* **确认号**：期望收到的对方下一个报文段的序号，即对方下一个报文段数据部分第一个字节的编号。
  * 与自己报文段的序号没有关系
  * 确认号 = 上一个收到的报文序号 + 上一个收到的报文数据长度
* **数据偏移**：本报文段中数据部分起始位置的偏移，本质上就是报文首部的长度
  * 每单位数据偏移表示4个字节，即数据偏移值为5，表示报文首部长度为20个字节
  * 占4位，所以报文首部最大长度为(2^4-1)*4)=60个字节
* **标志位**
  * URG：紧急报文，优先传输
  * ACK：ACK=1时确认号才有效，只有连接建立时才可能为0，其他时候ACK必须为1。
  * PSH：不等缓存填满，直接推送给应用程序
  * RST：复位
  * SYN：连接建立时用来同步序号。SYN=1表示本报文用于连接建立请求或接受
  * FIN：释放连接请求
* **窗口**：本报文段发送方的接收窗口大小
* 校验和：根UDP一样需要伪IP首部参与
* 紧急指针：指出紧急数据的位置
* 选项：随着网络发展，原始TCP不能满足使用需求，所以这部分主要是对TCP的扩展
  * 最初只有一个MSS——最大报文段长度
    * 用来控制TCP数据长度，使其既能够有高的网络利用率，又能够在IP层不分片。
    * 通信双方在连接建立时设置

###1.5.3 可靠传输

滑动窗口*(然而我总觉得可靠来自于序号和确认,根窗口没有关系...)*

* 发送方将数据暂存到发送缓存，直到收到接收方的确认
* 接收方对接收数据的连续最高序号给出确认

超时重传

### 1.5.4 流量控制

目的：通过控制发送方的发送速率，达到使接收方总是来得及接收数据的目的。

* 发送方发送窗口不能大于接收方接收窗口大小

* 如果发送方收到接收方的零窗口通知，则启动一个**持续计时器**，到时发送一个一字节的零窗口探测报文段。

### 1.5.5 拥塞控制

通过四个算法进行拥塞控制。

慢开始

* 拥塞窗口从最低值开始，逐渐增大(指数增长)：每经过一个传输轮次，拥塞窗口加倍

* 发生超时，慢开始门限减半，拥塞窗口降到最低，进入慢开始阶段

拥塞避免

* 拥塞窗口达到慢开始门限时，进入拥塞避免阶段
* 每经过一个传输轮次，拥塞窗口加一(线性增长)

快重传

* 接收方收到数据后就回复一个对连续最大序号的确认（不再捎带确认）

快恢复

* 发送方收到3个重复ACK后，慢开始门限减半，拥塞窗口等于慢开始门限，进入拥塞避免阶段

### 1.5.6 连接与释放

SYN报文不能携带数据，但要消耗一个序号

ACK报文可以携带数据，但没数据时不消耗序号

FIN报文可以携带数据，但要消耗一个序号

#### 1.5.6.1 连接

![](https://chrishuppor.github.io/image/Snipaste_2020-06-03_15-58-56.png)

三次握手：双方一共互传3个报文段

* 发起方发送SYN请求，接收方回复SYN及ACK，发起方回复ACK

注意：

* 如果接收方的SYN和ACK分开发送，就变成了四次握手
* 发起方最后回复ACK是为了 防止已失效连接请求到达接收方*（发起方不会回复接收方对已失效连接请求的回复）*

#### 1.5.6.2 释放

![](https://chrishuppor.github.io/image/Snipaste_2020-06-03_16-06-29.png)

四次挥手：双方一共互传4个报文段

* 发起方发送FIN请求，接收方回复ACK，发送方关闭自己到接收方的连接(即发送方不在发新的数据给接收方，接收方可以继续发数据到发起方)，TCP连接半关闭；
* 接收方发送完数据后，发送FIN+ACK，发起方回复ACK并启动时间等待计时器，接收方收到ACK后关闭自己方向的连接。
* 计时器到时，发起方撤销传输控制块，结束本次连接

注意：

* 释放时发起方和接收方并不同步，
* 发起方要等待一段时间再完全关闭TCP
  * 保证最后一个ACK到达接收方（如果接收方没有收到ACK就会重传FIN+ACK）
  * 防止有遗留的已失效的连接请求