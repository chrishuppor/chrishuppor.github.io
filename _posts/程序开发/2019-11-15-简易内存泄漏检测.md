---
layout: post
title: "简易内存泄漏检测"
date: 2019-11-15 9:16:18
categories: ErrSolution
tags: Windows
---

使用vc++提供的函数进行简单的内存泄漏检查。


# 函数

头文件：<crtdbg.h>  

检测函数：_CrtDumpMemoryLeaks()—在”输出-调试“中打印内存泄漏报告

定位函数：_CrtSetBreakAlloc(int)—参数是内存申请号，设置了内存断点，在申请这一个内存时中断。

## 注意事项

* _CrtDumpMemoryLeaks函数只能显示出内存泄漏的地址和内存编号，所以只有当程序始终按一个顺序申请内存时，才能用\_CrtSetBreakAlloc定位到泄漏位置。
* 需要程序是debug模式——使用MTd或MDd
* 要求程序自然退出，也就是说不能是中断调试或强行关闭的。

* 可以添加如下代码

```c
#ifdef _DEBUG
#define new   new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif
```

# 使用示例

## 检测

内存泄漏检测：

```c
#include <crtdbg.h>  

#ifdef _DEBUG
#define new   new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif
int main()
{
	byte *tmp = new byte[100];//内存泄漏代码
	_CrtDumpMemoryLeaks();
}
```

输出内容如下：

```
{117} normal block at 0x0073AD30, 100 bytes long.
 Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 
```

## 定位

在代码中添加_CrtSetBreakAlloc(117)，117就是要中断的内存号。

```c
#include <crtdbg.h>  

#ifdef _DEBUG
#define new   new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif
int main()
{
	_CrtSetBreakAlloc(117); //添加
	byte *tmp = new byte[100];
	_CrtDumpMemoryLeaks();
}
```

然后程序就会在第117次申请内存时断掉：

![](https://chrishuppor.github.io/image/Snipaste_2019-11-14_15-31-59.png)

# 其他方法

最简单的查看有没有内存泄漏的方式：查看程序运行时的内存和句柄。

* 运行procexploer，查看对应进程的属性->performance中的virtual memory和handle，如果有一直增加的问题就极大可能有泄漏问题：
  * virtual memory：申请了内存但用完没释放，最后导致内存用光；
  * handle：创建了句柄但没有释放句柄。windows允许程序拥有的句柄数量有上限，如果超过了这个上限就会有问题。