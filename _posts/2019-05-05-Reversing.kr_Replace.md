---
layout: post
title: "Reversing.kr_Replace"
date: 2019-5-5 22:29:21
categories: WriteUp
tags: Reversing_kr
---

微简RE challenge网站，my_4ear_3hr1s 就系我啦，5题解题过程及题后思考记录如下。

# Reversing.kr_Replace

## 5.Replace

### 破解过程

1. 运行程序

   程序需要输入一个字符串，然后点击check。如果失败，程序会崩溃；猜测如果成功，程序会改变下方提示信息。

2. 拖进PEiD、virustotal，没有什么异常。

3. 拖进IDA

   1. 查看字符串——有一个“correct”，应该是成功后会显示的信息。

   2. 查看IAT——有一个GetDlgItemInt函数，这个函数应该是从输入框中获取信息的。这个函数将输入框中的数据以整数的形式读取并返回。

   3. 转到correct的引用，使用F5，得到主逻辑反编译代码

      这个代码十分简单——从输入框获取数字，调用sub_404689和sub_40466F两个函数。其中，sub_404689函数就是将输入的数字加一，而sub_40466F却无法反编译。

      ![图1 check顶层代码](https://chrishuppor.github.io/image/Snipaste_2019-05-05_21-29-33.PNG)

      根据```*(_DWORD *)sub_40466F = 0xC39000C6```可知，sub_40466F函数的起始地址被写为C39000C6，即sub_40466F函数起始的机器码变为C39000C6，然后被调用。这里可能是关键点。

   4. 在反编译代码中找不到correct的信息,，这是十分奇怪的。直接查看correct相关汇编代码，该代码起始于0x401073，但没有发现有jmp到0x401073的引用，也就是说这处代码根本不会执行，也就意味着，破解的目的就是通过输入整数实现这段代码的运行。因此，输入肯定是引起了程序机器码的篡改。有两种猜想：

      * 利用输入覆盖某处机器码，使其jmp到0x401073
      * 利用输入覆盖某处机器码，使其不会jmp到其他地方，而是直接运行到0x401073

      当看到0x401071的jmp时，我认为极可能是第二种猜想，因此需要关注输入整数对程序代码的影响。

4. 拖进OD

   1. 定位到GetDlgItemInt函数的调用，在其调用的下一条指令处下断点。

   2. 运行程序，输入'123'，点击check

   3. 程序中断，查看中断之后的汇编代码。

      如图，首先将输入的整数赋值给[0x4084D0]，然后调用0x40466F。

      ![图2 输入整数赋值给[0x4084D0]](https://chrishuppor.github.io/image/Snipaste_2019-05-05_21-39-51.PNG)

      跟进0x40466F，发现该函数是对[0x4084D0]进行了加的操作。该函数结束后，[0x4084D0]变为[0x4084D0]+4+0x601605c7。

      接下来跳转到0x404690，然后会将[0x4084D0]赋给EAX，再将C39000C6写到[0x40466F]，之后会跳转到0x401071。

   4. 0x40469F之前的代码功能十分明确，直接运行程序到0x4046A9。

      此时0x40466F处的机器码已被修改，如图，sub_40466F的功能变为了将[EAX]修改为90。而90正式NOP，这是我们希望的0x401071处的代码，也就是说如果EAX = 0x401071，则能够实现程序逻辑篡改。

      ![图3 0x40466F处的机器码](https://chrishuppor.github.io/image/Snipaste_2019-05-05_22-01-22.PNG)

      然而0x401071的机器码是两个字节长度，一个NOP是不够的。查看0x4046A9后续代码，发现恰好之后会对EAX加一并再次调用0x40466F。说明这个思路是正确的，作者已经为我们篡改代码铺好了道路，只需要我们去触发。

   5. 追溯EAX值的来源——来自[0x4084D0]。而[0x4084D0]正是对输入整数处理后的结果存储地址，易得[0x4084D0] = （<input_int>+ 2 + 0x601605c7 + 2）mod 0x100000000。当输入能够使[0x4084D0] = 0x401071时，程序破解成功。所以 <input_int> = （0x401071 - 0x601605c7 - 4）mod 0x100000000。

   ### 小结

   * 出题思路：通过输入的数据覆写程序代码，从而篡改程序逻辑。
   * 该类题目一般都会有以下某个特征：
     * 需要执行的逻辑始终不被执行
     * 用户的输入可以引起数组越界
   * 本题使我想起了两个汇编知识
     * call XXX = jmp XXX，只不过正常情况下call XXX时，XXX代码后面有一个retn，但可以没有这个retn。
     * 默认DS:[EAX] = [EAX]