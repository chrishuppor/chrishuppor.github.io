---
layout: post
title: "c++设计模式"
date: 2020-3-4 22:7:1
categories: LearningNote
tags: c++
---

在B站找到的一门c++设计模式课，老师通过示例详细讲解了23种模式的动机、应用场景和效果，同时也讲了很多模式之外的设计思想，令人受益匪浅。


# 概述

软件设计的最终目标：复用——需求发生改变时不需要修改原来已经编译好的文件，只需要进行扩展

复用的关键：抽象——对抽象模型进行通用处理

![图](https://chrishuppor.github.io/image/Snipaste_2020-03-01_22-55-30.png)

设计模式的核心思想——将程序中稳定的部分与变化的部分分离开

- 提高稳定部分的复用
- 使变化的部分更加灵活

设计模式的应用时机——重构时。

- 没有一步到位的设计模式，都是在迭代中不断重构，在重构中应用更好的设计模式。
- 设计模式的应用关键是思想的应用，不能误入模式格式套用的歧途。

重构技巧

- 静态->动态
- 早绑定->晚绑定
- 继承->组合
- 编译时依赖->运行时依赖
- 紧耦合->松耦合

*PS.可能不同代码之间相差很小，但其蕴含的设计思想却完全不同。设计对于不再变化的代码是没有意义的，衡量一个设计的好坏要看变化发生时代码能不能高效稳定的扩展*

# 面向对象设计原则

* **最终目的**——让变化对代码的影响降到最小

* 实现关键——把稳定的部分保护起来

八个设计原则——设计模式的基础

* 依赖倒置原则：程序要依赖于抽象接口，不要依赖于具体实现。

* 开放封闭原则：可扩展不可改变，如可增加子类，不可以修改已存在的类。

  ```c++
  //对于 class A{};修改和扩展示例如下
  //修改
  class A
  {
      int add;
  }
  //扩展
  class B:public A
  {
  	int add;
  };
  ```

* 单一职责原则

* 里式替换原则：任何基类可以出现的地方，子类一定可以出现。

  * 继承复用——只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为

* 接口隔离原则：不对客户开放它们不需要的方法(只public客户需要的)

* 优先使用对象组合而不是类继承

  * 子类知道并有可能修改从父类继承的方法，破坏了父类的封装，子类父类紧耦合。

  * 包含对象的类是不知道该对象的内部实现的，是松耦合。

    ```c++
    //类继承
    class A{};
    class B:public A{};
    //对象组合
    class A{};
    class B{A a;};
    ```

* 封装变化点：使用封装将稳定部分和变化部分隔离。

* 使用接口编程：在程序中使用接口，而不是使用具体类。

  ```c++
  //有如下三个类，显然Shape是接口。
  class Shape{virtual void draw()=0;};
  class Line:public Shape{virtual void draw(){cout<<"line";}};
  class Rect:public Shape{virtual void draw(){cout<<"rect";}};
  
  //使用接口编程：无论是line还是rect都可以使用这个函数
  void Draw(Shape* p)
  {
      p->draw();
  }
  
  //使用具体类编程：只有line可以使用这个函数，要想调用rect::draw还要重载一个函数
  void Draw(Line* p)
  {
      p->draw();
  }
  ```

PS.**标准化**的重要性——对于小规模、手动的工作来说，只要能做出来，怎么做都可以；但要想扩大规模、自动化、形成产业，就必须标准化。只有标准化的接口，才能是使参与者高效的分工协作。

# 组件协作类型

* 将程序划分为**框架**和**应用程序**
* 实现框架与应用程序之间的松耦合

## 模板方法

* 关键点

  * 稳定的流程交给框架实现，变化的子步骤交给应用程序实现

* 要点总结(课件原文)

  >- Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。
  >
  >- 除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用。
  >- 在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法。

* 示例

  ```c++
  //框架
  class Frame
  {
      void step1(){/*...*/}
  protected:
      virtual void step2() = 0;//子步骤接口
  public:
      void DoWork()//应用程序只需要继承这个类，然后实现step2()，相当于框架调用的应用程序
      {
          step1();
          step2();
      }
      virtual ~Frame(){/*...*/}
  }
  
  //应用程序
  class CustomFrame:public Frame
  {
  public:
  	void step2(){/*...*/}
  }
  int main()
  {
      Frame* mf = new CustomFrame();
      mf->DoWork();
      return 0;
  }
  ```

* 模式类关系图

  ![图](https://chrishuppor.github.io/image/Snipaste_2020-03-03_19-57-57.png)

## 策略模式

* 动机

  * 隔离算法变更带来的变化，将算法与对象解耦

* 关键点

  * 接口不变，根据需要调用不同的算法。(不是if-else结构，而是使用虚函数的多态实现。)

* 要点

  >* Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。
  >* Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。
  >* 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。

*PS.与模板方法一样是基础常用的模式。*

* 模式类关系图

  ![图](https://chrishuppor.github.io/image/Snipaste_2020-03-03_19-52-59.png)

## 观察者模式

* 动机

  * 解决有通知依赖关系的对象之间的紧耦合

* 关键点

  * 在通知依赖关系的对象之间构造一个通知机制抽象接口，发送通知的对象A通过这个接口广播通知，接受通知的对象B只需要实现这个接口并注册到A的通知队列

* 要点总结

  >* 使用面向对象的抽象，Observer模式使得我们可以**独立地改变目标与观察者**，从而使二者之间的依赖关系达致松耦合。
  >* 目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。
  >* 观察者自己决定是否需要订阅通知，目标对象对此一无所知。
  >* Observer模式是**基于事件的UI框架**中非常常用的设计模式，也是MVC模式的一个重要组成部分。

![图](https://chrishuppor.github.io/image/Snipaste_2020-03-03_20-21-24.png)

# 单一职责类型

## 装饰模式

* 动机
  * 解决使用继承扩展对象功能带来的子类个数膨胀问题
* 目的
  * 实现主体类在多个方向上的功能扩展
* 关键点
  * 创建一个修饰类，该类中包含一个指向基类对象的指针（在实际使用中可以指向主体类对象），然后在修饰类的子类中对该指针指向的对象进行功能扩展。（优先使用对象组合）
  * 类中定义的对象指针是基类对象的指针，使用时可以是基类的派生类对象指针（里式原则）
* ![图](https://chrishuppor.github.io/image/Snipaste_2020-03-03_22-06-02.png)

## 桥模式

* 动机
  * 解决基类在多个维度上的继承问题（不是功能扩展，而是每个子类只继承基类的一部分）
* 关键点
  * 将基类按子类继承方向进行拆分，然后在基类中包含指向不同方向子类对象的指针。
  * 典型应用
    * 将基类拆分为业务功能和平台实现，然后在业务功能中包含一个指向平台实现的指针
* ![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_10-31-52.png)

# 对象创建模式

* 解决对象创建时的问题
  * 使用new创建对象，创建的是具体类的对象，依赖的是细节，违背了针对接口编程和依赖倒置原则。

## 工厂模式

* 关键点
  * 将对象创建封装为一个抽象类，通过继承该类来创建具体对象
  * 其他类调用该接口创建对象，在运行时决定创建哪个具体对象，从而实现该类的稳定
* ![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_11-23-36.png)

## 抽象工厂

* 动机
  * 需要创建一系列相关的具体类的对象（这些对象相互关联，不能拆开使用）
* 关键点
  * 对于只需要创建一个具体类对象的问题，使用工厂模式就可以了
  * 对于一系列具体类对象的创建问题，可以将这些类对应的工厂聚合到一个类中
* ![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_12-07-49.png)

## 原型模式

* 动机
  * 解决工厂模式中新建对象的初始化问题，尤其是初始化较为麻烦时。
* 关键点
  * 将工厂模式中的工厂基类与具体类的抽象类合并，形成支持克隆的原型类
  * 客户创建一个原型类的具体类对象，初始化该对象并将指针作为抽象类对象指针传递给调用该类的类，每次调用类需要实例化具体类对象时，就使用该指针调用克隆函数，创建一个与该对象状态一致的新对象。
* 用的比较少，因为一般工厂模式就够用，很少遇到初始化很麻烦的类。
* ![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_15-10-23.png)

## 构建器模式

* 应用场景
  * 某个对象初始化时需要通过一个算法来创建多个对象
  * 算法相对稳定，但对象存在变化
* 做法
  * 将初始化对象的算法分离出来，单独封装一个构造类
* 用的比较少，因为很少用到这么复杂初始化，模板方法已经够用了
* ![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_15-39-14.png)

# 对象性能模式

## 单件模式

* 只允许有一个实例存在
  * 不能把很多事情交给使用者，应该由类自己来控制
* 做法
  * 将构造函数、拷贝构造函数声明为私有
    * 保证其他类不能从这个类派生
    * 除使用本类方法无法创建本类的实例，也就是系统不能自动创建这个类的实例
  * 将实例指针设置为static
    * 类中static成员是所有对象共享的
  * 设置一个public并且static的方法来实例化实例指针，如果已经实例化则直接返回该实例的指针
    * 类中的static方法能够访问类的私有成员 
    * 保证对象创建在堆上
    * 类的静态成员函数可以不通过对象直接调用

```c++
class Singleton{
private:
    Singleton(); //私有构造函数
    Singleton(const Singleton& other);//私有拷贝构造函数
public:
    static Singleton* getInstance();//静态方法
    static Singleton* m_instance;//实例指针
};
Singleton* Singleton::m_instance=nullptr;

//版本1：线程非安全版本
Singleton* Singleton::getInstance() {
    if (m_instance == nullptr) {//如果多个线程同时运行到这里，都认为m_instance为空
        m_instance = new Singleton();
    }
    return m_instance;
}

//版本2.1：线程安全版本，但锁的代价过高
Singleton* Singleton::getInstance() {
    Lock lock;//锁本身有代价，所以要尽可能减少锁的使用
    if (m_instance == nullptr) {
        m_instance = new Singleton();
    }
    return m_instance;
}

//版本2.2：双检查锁，但由于内存读写reorder不安全（reorder是编译器优化的结果，就是将原来的指令执行顺序优化为等价指令执行顺序）
Singleton* Singleton::getInstance() {
    
    if(m_instance==nullptr){
        Lock lock;
        if (m_instance == nullptr) {
            m_instance = new Singleton();//这里可能reorder：本来是先创建实例再将地址返回给m_instance；reorder之后可能先申请空间返回给m_instance，然后再这个创建实例。
            //reorder之后，如果线程A运行到先申请空间返回给m_instance，但没有创建实例。线程B运行到检查m_instance是否为空，则因为m_instance不为空，B将得到一个未实例化的地址。
        }
    }
    return m_instance;
}

//版本3：指明不可以reorder的代码，C++ 11版本之后的跨平台实现 (volatile)
std::atomic<Singleton*> Singleton::m_instance;
std::mutex Singleton::m_mutex;

Singleton* Singleton::getInstance() {
    Singleton* tmp = m_instance.load(std::memory_order_relaxed);
    std::atomic_thread_fence(std::memory_order_acquire);//获取内存fence
    if (tmp == nullptr) {
        std::lock_guard<std::mutex> lock(m_mutex);
        tmp = m_instance.load(std::memory_order_relaxed);
        if (tmp == nullptr) {
            tmp = new Singleton;
            std::atomic_thread_fence(std::memory_order_release);//释放内存fence
            m_instance.store(tmp, std::memory_order_relaxed);
        }
    }
    return tmp;
}
```

## 享元模式

* 动机
  * 解决大量细粒度对象充斥系统的问题（具体多少算大量，需要根据实际情况进行评估）
* 应用场景
  * 有许多客户需要使用对象，且使用的对象类型、状态等一致，且都不改变对象，则可以使这些客户共享一个对象。

* 关键点
  * 共享的思想和方式
  * 构建一个对象池，每次创建对象前都先去池中查找，如果已经创建则返回对象指针，如果没有则创建新对象并返回指针

# 接口隔离模式

当有什么问题解决不了的时候，考虑添加一个中间层，来**间接**的解决（计算机领域常用方法——人难以直接控制硬件，于是找了软件做中介）

## 门面模式

![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_17-13-26.png)

* 从架构层次来设计整个系统，实现子系统与外部客户之间的解耦。

## 代理模式

![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_17-23-09.png)

* 在一些特殊的情况下，不方便直接访问对象，则可以创建一个代理，来实现对对象的访问。
  * 架构很简单，但代理的实现会很复杂。

## 适配器模式

* 应对接口不兼容的匹配问题。
* ![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_17-43-36.png)
* 继承接口：遵循这个接口定义的规范（所以继承目标接口）
* 分类
  * 对象适配
    * 组合对象：支持这个对象的实现（所以组合遗留接口的对象）
  * 类适配（极少用）
    * protected继承遗留接口的具体类（缺少灵活性），属于实现继承——不用这个的类的规范，使用这个类的实现。

## 中介者模式

* 动机

  * 应对多个对象互相关联交互的问题。

* 思想

  * 使各个对象之间不需要显示的相互引用，将编译时依赖转为运行时依赖

    ![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_18-16-32.png)

# 状态变化

## 状态模式

* 问题
  * 对象的状态发生变化时，对象的行为也可能发生变化
* 动机
  * 在对象状态发生变化时，能够动态的改变对象行为

* 实现
  * 创建一个状态抽象类，为不同的状态创建不同的具体类并实现对应的行为。对象只需要通过状态指针调用对应的行为，而具体使用什么方法则在运行时根据指针指向的对象类型来决定。
* ![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_18-40-32.png)

## 备忘录模式

* 应用场景
  * 需要回溯对象的状态
* 动机
  * 在不破坏封装性的条件下，访问对象内部状态并保存在外部
* 实际就是对象状态保存

# 数据结构模式

将数据结构与处理算法解耦。

随着技术的发展，数据结构模式都有些过时了。（李老师说的）*

## 组合模式

* 目的

  * 对于一个对象容器（容器是变化的），外部代码能够不依赖容器，像处理简单对象一样处理整个对象容器。
* 实现

  * 在类内部实现对象容器的递归处理，客户代码只需要传入一个对象，不需要知道这个对象是简单的还是复杂的容器。

* 要点

  ![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_20-40-53.png)

## 迭代器模式（已过时）

* 目的
  * 对于一个对象集合（数据结构是变化的），外部代码能够不依赖其数据结构，透明的访问其中包含的元素。
* 实现
  * 通过接口隔离算法和容器（数据结构）
    * STL中使用模板函数实现（编译时绑定，性能更好）

## 职责链模式

* 目的
  * 消息发送者与消息处理者解耦

![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_21-05-12.png)

SEH就是用的这种模式。

![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_21-06-06.png)

# 行为变化模式

将组件行为与组件本身解耦。

## 命令模式

![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_21-17-57.png)

## 访问器

* 应用场景
  * 子类是稳定的，对子类的操作是变化的
* 动机
  * 为基类添加新操作时，需要同时更改所有子类，十分不方便，违背了开闭原则。

![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_21-44-30.png)

# 领域规则模式

## 解析器模式

![图](https://chrishuppor.github.io/image/Snipaste_2020-03-04_22-05-16.png)