---
layout: post
title: "Clean Code学习笔记"
pubtime: 2019-04-30 8:8:8
updatetime: 2019-04-30 8:8:8
categories: LearningNote
tags: Book
---

clean code 学习笔记。技术指导类的书，学习的关键是应用。

# Clean Code学习笔记

《Clean Code》是作者对自己多年编程经验的总结，意在为广大程序员同行提供整洁代码的方法和范例。这本书是一部指导性的书，首先给出了整洁代码应该遵循的规则，然后给出了编写整洁代码的步骤，最后给出了一个完整的范例。

## 整洁代码阐述

名不正则言不顺，言不顺则事不成，编写整洁代码就要清楚什么是整洁代码。本书首先对整洁代码进行了阐释——**高模块化、低耦合、高可读性、高稳健性**的代码。整洁代码之间的依赖极少，不会牵一发而动全身，每一部分都可以单独进行测试；整洁代码内容简洁明了，其字面意思能够直接表达其功能，使编写者以外的人可以直接读懂代码而不需要借助其他信息；整洁代码是通过了完整的单元测试的，代码中的每一个模块、每一个函数经过了测试。

做任何事情都是有原因的，否则就不必去做。尤其是做一件需要耗费精力的事时，充分且合理的理由会让我们觉得这件事有意义，才能让我们心甘情愿的为之“赴汤蹈火”。维护代码整洁就有这样的理由。本书首先说明了代码的重要性——代码呈现了需求的细节，是驱动机器工作的“详细要求”。因此，**代码的好坏直接影响程序的工作状态**。本书接下来从糟糕代码的坏处和整洁代码的好处两角度出发不遗余力的阐述了编写整洁代码的意义。书中将糟糕的代码比喻为沼泽，并且举了一个系统开发的例子，生动形象的说明了糟糕的代码会降低开发效率、增加修改成本、增加沟通成本、“藏污纳垢”，是项目中的不稳定因素。与之相反，整洁代码会带来诸多好处：易于沟通、易于复用、易于测试、易于更新、易于发现BUG。总之，**在编写糟糕代码的时候省掉的精力都会成倍的浪费在其他工作中，而编写整洁代码会使开发中的很多工作都变得方便易行**。

## 具体规则

讲清楚道理之后，就要讲如何做了。本书从十二个方面给出了具体的规则：命名、函数、注释、格式、对象和数据结构、边界（接口）、单元测试、类、迭进和并发编程。

* 命名
  * 命名要做到**名副其实**，让人通过名称就能知道这个变量或函数的关键信息；
  * 避免歧义，**尽量使用大家都接受的说法**（例如msdn的命名），同一个概念取相同的名称；
  * 要**可读**，既于记忆也便于交流；
  * 要**可搜索**，即通过字符串查找就可以找到其位置，而不是像i这种通篇都有；
  * 注意**词性**，变量用名词，函数用动词。

* 函数
  * 功能单一——一个函数只完成一个功能，从而保证函数不会太长
  * 结构清晰——函数中每个操作都在一个抽象层次；每个函数紧邻下一抽象层次的函数；代码成块存在，能够单独测试
  * 参数合理——参数个数不要太多，过多的参数可以封装成结构体；参数顺序要合理，符合习惯即可
  * 错误、异常处理——异常处理要和正常逻辑分开，编写代码时也可以先写正常逻辑，再写异常处理逻辑

* 注释——**注释不属于代码，不能依靠注释表明代码意图**
  * 越少越好——理想的代码可以通过代码本身讲清楚自己做的工作，不需要注释；代码更新的时候，往往忽略注释的更新，而过时的更新会让人产生误解，还不如没有。
  * 有些注释是必须的——法律声明等；提供样例；解释代码说不清的信息；标记需要改进的位置。

* 格式——为了代码**易读和易扩展**

  * 垂直格式
    * 从源文件中最高概念开始向一个方向发展（*书中表示要自上向下发展，但这样需要写很多声明，所以我喜欢自下向上发展，即将下一层概念写在本层概念的上面*）
    * 相关代码放在一起
    * 使用空行进行分割——函数之间的分割和模块之间的分割
  * 横向格式
    * 一行代码不要太长
    * 使用空格分割不相关的信息
    * 如果有空循环，;一定要单独成行
  * 统一团队格式

* 对象和数据结构（类和结构体）

  * *其实和变量、函数的规则无差*

* 边界（接口）

  * **接口的实现要高封装，**一个接口内部实现代码的变动不影响使用该接口的代码
  * 接口要能够通过单元测试
  * 接口的实现与否不影响该接口在其他代码中的使用

* 单元测试

  * 代码编写，测试先行，只有通过了测试的代码才可以加入到生产代码中
  * 测试代码结构——构造数据>操作数据>验证数据
  * 测试代码要求
    * 整洁——	因为测试代码与生产代码一样重要，而且测试代码要与生产代码一起改动
    * 高效——因为测试会频繁进行
    * 独立——测试以单元的形式进行，不同单元之间没有关系
    * 单元化——一个测试函数只负责一个测试内容
    * 兼容性——测试应该在各种环境下都通过才算测试通过
    * 自验证——测试程序自行判断测试是否通过

* 类

  * 单一权责
    * 一个类只完成一个任务——如果不能用单句描述任务则表明任务过多，需要拆分
    * 清晰的类名称——类名越模糊说明类功能越冗杂，需要拆分
  * 内聚——如果有些变量只有一部分方法使用了，那么这些变量和方法可以自成一类
  * 减少修改的影响
    * 添加功能、修改功能尽可能的不影响到类
      * 通过添加新类的方式添加功能
      * 修改功能只是修改有这个功能的类
    * 应该为功能中有一部分相同功能的方法抽象出类，然后这些方法作为派生类

* 迭进

  * 在最初的简单结构上添加的新内容都要经过测试

* 并发编程——难点在于共享信息同步

  * （具体信息如图，[原图地址](https://chrishuppor.github.io/image/2019-4-30.png))

  ![图1 并发结构整洁代码编写脑图](https://chrishuppor.github.io/image/2019-4-30.png)

## 代码生长范例

最后，本书给出了代码重构的步骤和一个代码生长的示例。最初设计的代码大多是简单整洁的，并且允许进行代码扩展。当需求增加时，会在原有代码的基础上进行添加。尽管最初的设计可能预留了代码添加的空间，但当需求越来越多时，添加的代码也就越来越多，原有的设计已经不能保持代码的整洁，代码就会变得混乱不堪。这时就需要进行代码重构，**逐步改进**代码，从而获得整洁代码。示例首先展示了一份简单的代码由小变大、由简单变复杂、由整洁变混乱的过程，然后展示了将混乱的复杂的代码逐步改进为整洁代码的过程。逐步改进时，可以从逻辑入手，将通用的逻辑封装成函数，将逻辑联系紧密的变量封装成结构体，将错误处理整理封装，将承担了多个功能的函数拆分。

## 后记

大家都喜欢整洁代码，但究竟什么样的代码是整洁的，每个人都有自己的看法；如何编写整洁代码，不同的人有不同的方法，针对不同的代码也有不同的方法。前辈的经验十分宝贵，但经验是不能照搬的。本书为我们提供了一种很好的思路，我们应该根据实际情况实事求是的改进自己的代码。

之所以学习Clean Code，是为了提高专业水平，为了提高自己代码的质量，为了让自己和代码有“高级”感和专业感。然而，只学习不总结就是狗熊掰棒子，要及时总结自己的收获、理解和想法，因此有了这篇“学后感”；只总结不复习就是熊瞎子掰苞米，记得常来看，期待新想法的迸出！当然，任何学习都是以用为目的的，技术的学习更要多多实践。