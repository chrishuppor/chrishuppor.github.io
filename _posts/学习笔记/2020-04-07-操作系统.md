---
layout: post
title: "操作系统基础"
pubtime: 2020-4-7 8:8:8
updatetime: 2020-4-7 8:8:8
categories: LearningNote
tags: Course
---

哈工大李治军老师的操作系统基础课程学习笔记，主要包括进程管理、内存管理、IO管理、文件系统四部分。(课程视频在B站上有，所以B站确实是个学习软件)

# 概述

1. 操作系统地位

   1. 位于应用软件和计算机硬件之间，负责管理硬件，为软件提供服务。（本质也是软件，只不过是特殊的、功能稳定的软件）

      ![图](https://chrishuppor.github.io/image/Snipaste_2020-03-22_10-47-05.png)

2. 操作系统硬件管理

   ![图](https://chrishuppor.github.io/image/Snipaste_2020-03-22_10-49-45.png)

3. 计算机五大部件(硬件)

   输入、输出、存储器、运算器、控制器

4. 计算机工作的核心——**取指执行**

## 计算机的启动

(将操作系统读入内存，进行初始化。)

1. 运行BIOS。

   * BIOS是存储在主板的ROM里面的，不用调入内存就可直接被CPU运行（此时内存是空白的）。为了提高性能，会将BIOS映射到内存中，因为RAM的读写比ROM快。

   * BIOS负责**硬件检查**，**加载引导扇区到内存**，并将控制移交给引导扇区起始地址。

     ![图 x86上电运行BIOS的过程](https://chrishuppor.github.io/image/Snipaste_2020-03-22_11-50-35.png)

     * x86的引导扇区在磁盘的0磁道0扇区，共512字节，BIOS将其读入0x7c00处，并将cs:is设置为0x7c0:0（0x7c00之前的空间是预留给操作系统的）

2. 运行引导扇区(bootsect.s)

   * 使用汇编语言——因为汇编语言可以直接转换为机器代码，是完全可控的。而高级语言不是程序员完全可控的，比如变量的存储位置。

   * 完成的工作

     1. 移动bootsect.s代码。

        首先将bootsect.s程序从7c00处移动到0x9000h(rep movw)，共512字节；设置cs/ds/es/ss为0x90000h，sp:ff00h

        ![图 bootsect.s关键代码](https://chrishuppor.github.io/image/Snipaste_2020-03-22_14-48-17.png)

     2. 加载setup.s程序

        * 读取磁盘中bootsect后面的四个扇区(一共1K字节)到0x9200h

     3. 打印Loading system ...

     4. 加载system。

        cc从磁盘setup.s程序后继续加载system文件

     5. 跳转到setup.s开始执行（修改CS和IP为 0x902和0x0）

3. 运行setup.s

   * 完成OS启动前的设置，接管硬件。

     * 获取硬件参数，包括内存大小、显卡型号等。

     * 将操作系统移动到0地址
     * 初始化IDT和GDT表(为了jmpi 0,8，OS会再次初始化)
     * 进入保护模式——启动32位寻址方式
       * 原来的cs:ip的寻址方式(cs<<4+ip)只能访问1M的空间
       * jmpi 0,8不在使用原来的方式，而是需要通过GDT表寻址，实际就是0x0

4. 运行system

   * 开始使用32位汇编代码（之前用的都是16位的）
   * 开始由汇编转到c
     * head.s->main.c
   * 初始化内存、中断、时钟等对应的数据结构和数据(GDT、IDT等表)
     * eg:初始化内存管理数组，将OS外的所有内存清零。

## 操作系统的接口

### 客户如何使用计算机？

客户通过应用软件来使用计算机。

* 命令行：命令程序
* 图形界面：消息框架程序+消息处理程序

### 应用程序如何使用计算机？

应用软件通过操作系统接口使用操作系统，进而使用计算机硬件

* 操作系统接口是一组操作系统实现的供应用程序调用的函数，又称为**系统调用**

ps.不同的操作系统对系统调用的实现有差别，但接口都遵循一定的标准(如unix的POSIX标准)

### 为什么应用程序要用系统调用而不是直接调用OS内部函数？

* 为了操作系统的稳定和安全，不允许应用程序直接访问操作系统的内存，只允许使用操作系统提供的接口，即系统调用。
  * 稳定
    * 应用程序的稳定性要比操作系统差，经常崩溃，如果应用程序可以随意访问OS，则很容易导致OS崩溃
  * 安全
    * 如果应用程序可以随意访问操作系统，则可以获取到其他应用程序流入操作系统的数据，也可以获取到操作系统的关键数据(如root密码)

### 如何强制应用程序不能直接访问内核？

* 通过**硬件设计**将内存划分为**内核段和用户段**。内核段运行内核程序，用户段运行用户程序
  * 原理：在head.s中初始化GDT时设置各个内存段的特权级DPL，在访问时检查当前特权级CPL，如果DPL>=CPL时则允许访问，否则拒绝。
  * 特权级：内核态特权级为0， 用户态特权级为3；特权级数字越大级别越低。DPL是在GDT表初始化时设置的，CPL是OS启动后设置为3、进入内核后设为0、出内核后设为3.

### 应用程序如何访问内核？

- 使用系统调用(或者操作系统库函数，如winAPI，库函数内含对系统调用的调用)

### 应用程序在用户态，如何进入内核调用系统调用？

中断——通过int指令将CPL改为0。(仍然是由硬件支持)

* int 0x80

![图 系统调用核心流程](https://chrishuppor.github.io/image/Snipaste_2020-03-23_10-34-41.png)

通过int 0x80并提供系统调用号，则可以进入内核调用相应的系统调用。

### 应用程序如何调用系统调用？

应用程序调用c库函数-》c库函数调用系统库函数-》系统调用

![图](https://chrishuppor.github.io/image/Snipaste_2020-03-23_10-42-54.png)

应用程序使用int 0x80进入内核，内核进行中断处理，然后根据系统调用号从系统调用表中取出对应地址，然后调用。

![图](https://chrishuppor.github.io/image/Snipaste_2020-03-23_11-17-21.png)

### int 0x80进入内核的原理？

1. 初始化IDT表时，将int 0x80对应的中断的DPL设置为3，则中断发生时，CPL = 3 = DPL，允许执行。然后将CPL设为0，则可以进入内核了。

2. 中断返回时将CPL设为3。

# 进程管理：多进程概述

## CPU

工作原理：自动取指执行

提高CPU利用率：**并发**（多道程序同时出发，交替执行）

## 多进程

进程——加载到内存中运行的程序。

* PCB：进程控制块，用来记录进程信息的数据结构，用于进程切换管理
  * 进程切换时保存和恢复现场数据

## 多进程组织

* 执行
  1. 任务队列——根据进程状态将进程的PCB添加到不同的任务队列，等待执行
  2. 任务调度——进程切断规则
  3. 任务切换——将进程运行现场保存到PCB中，然后切回来时从PCB恢复现场。

* 共存
  1. 进程空间隔离——通过虚拟内存与物理内存的**映射表**来实现多进程的地址空间分离，防止进程之间互相影响

* 合作
  1. 同步
  2. 通信

![](https://chrishuppor.github.io/image/Snipaste_2020-03-24_10-03-43.png)

# 进程管理：多进程切换

指令切换+资源切换（进程的资源是OS给的，需要由内核进行管理，所以进程切换一定是内核级的）

## 线程

* 进程是资源分配的最小单元，线程是执行的最小单元

![](https://chrishuppor.github.io/image/Snipaste_2020-03-24_10-11-18.png)

* 线程优点

  既保留了**并发**的优点，又避免了**进程切换的代价**(不需要切换进程资源，不需要修改映射表)

* 线程资源

  同一进程中的线程共享进程资源，但不共用栈，进程为每个线程分配一个栈。（否则会出现A线程的函数返回时可能跳到B线程中的错误）

* TCB：线程控制块，用来存放线程的寄存器、栈等信息。

## 用户级线程

在用户态实现多线程切换，但在内核仍然是单线程。

* 优点：不需要进入内核，可以由用户控制，切换速度快
* 缺点
  * 在内核看来仍然是单线程进程
    * 一旦某个线程进入了内核并阻塞，内核会切换到另外的进程运行。
    * 不能充分利用多核

![](https://chrishuppor.github.io/image/Snipaste_2020-03-24_10-54-57.png)

## 内核级线程

多核可以实现多个内核级线程并行（即同时运行）

![](https://chrishuppor.github.io/image/Snipaste_2020-03-24_11-16-46.png)

* 与用户级线程区别
  * 两个栈：内核级线程分为运行在用户态的部分和运行在内核态的部分，因此需要用户栈和内核栈两个栈\
  * TCB由内核管理

![](https://chrishuppor.github.io/image/Snipaste_2020-03-24_11-33-15.png)

* 内核级线程切换——找到TCB（在内核），切换内核栈（内核栈关联用户栈），中断返回后实现用户栈的切换

![](https://chrishuppor.github.io/image/Snipaste_2020-03-24_11-56-15.png)

# 进程管理：多进程调度

从任务队列中取任务执行

## 调度目标

* 这三个目标互相约束，不同的任务的关注点也不同，所以要折中平衡。

![](https://chrishuppor.github.io/image/Snipaste_2020-03-24_17-02-34.png)

## 基本调度算法

* FCFS先来先服务
  * 优点：最公平
  * 缺点：太简单，不能考虑到实际中复杂情况的特点
* SJF短作业优先
  * 优点：最短平均周转时间
  * 缺点：长作业的响应时间无法保证
* RR时间片轮转调度
  * 优点：保证平均响应时间较小
  * 缺点：需要频繁切换
* Priority
  * 直接想法：前台任务关注响应时间，使用RR；后台任务关注周转时间，使用SJF
  * 静态优先级策略：如果一直有高优先级任务，造成优先级低的任务饥饿
  * 动态优先级策略：如果后台任务优先级高于前台任务优先级，影响前台任务响应时间

## Linux0.11调度算法

核心思想：将时间片作为优先级的优先调度算法，并且时间片是动态变化的

代码：

![](https://chrishuppor.github.io/image/Snipaste_2020-03-24_18-09-24.png)

优势

![](https://chrishuppor.github.io/image/Snipaste_2020-03-24_18-14-10.png)

# 进程管理：多进程同步

进程合作模型：

* 生产者/消费者模型
  * 场景：生产者向缓冲区放入数据，消费者从缓冲区取出数据。
  * 问题：生产者和消费者需要知道缓冲区剩余空间、已用空间，否则可能会溢出或访问错误。
  * 解决：信号量
* 读者/作者模型
* 哲学家模型

## 临界区保护

竞争条件

* 多个进程并发操作共享数据引起错误

竞争条件解决——原子操作/临界区：一次只允许一个进程进入的一段代码

### 临界区保护原则

* 互斥：一次只允许一个进程进入
* 有空让进
* 有限等待

### 临界区保护方法

#### 软件方法

* 基础思想

  * 轮换法

    * 不能有空让进：P0完成后，尽管P1可能不在临界区，但P0不能再次进入

    ![](https://chrishuppor.github.io/image/Snipaste_2020-03-25_10-21-17.png)

  * 标记法

    * 不能有空让进：P0在flag[0] = true后切到P1，P1在flag[1] = true后切回P0，则P0和P1都不能进入临界区

    ![](https://chrishuppor.github.io/image/Snipaste_2020-03-25_10-23-14.png)

* **Peterson算法**(两个进程)

  * 如果有其他进程的标记(其他进程要求进入)且该其他进程，则等待，否则进入。

* **面包店算法**(多进程)

  * 进程想进入时取号，每次允许序号最小的进程进入
    * 如果有其他进程想进入且该进程号码小于自己的号码，则等待。

#### 硬件方法

* **关闭中断**——进程调度才会有发生竞争，所以阻止调度就能阻止竞争
  * 只能关闭单个CPU的中断，没办法关闭多个CPU(或多核)，所以无法控制其他CPU的调度
* **硬件原子指令**——将进入和离开临界区的代码在硬件层面设置为原子指令
  * 适用于多个CPU。多核CPU会有其它规范来实现原子操作，最粗暴的就是让大家都等一等（一瞬间变成单核，执行完再放开）。

## 死锁

*我等待的条件最终依赖于我等待的条件，于是我就被锁住了。*

### 什么是死锁

多个进程**互相等待对方持有的资源**而造成谁都无法执行的情况称为死锁。

### 死锁的必要条件

* 资源互斥使用
* 资源不可抢占
* 保持一个资源，请求下一个资源
* 循环等待

### 处理方法

![](https://chrishuppor.github.io/image/Snipaste_2020-03-25_11-25-44.png)

* 预防——破坏死锁条件
  * 一次性申请全部资源
  * 按固定顺序申请资源

* 避免——每次申请资源就检测是否会造成死锁，当发现死锁时就拒绝。

  * 银行家算法——根据资源剩余量、进程需要资源量来判断该进程获得资源是否是安全的。

    * 效率低，如果每次申请资源都检测，则时间代价太大，所以通常在检测+恢复是使用。

    ![](https://chrishuppor.github.io/image/Snipaste_2020-03-25_11-33-33.png)

* 检测+恢复——检测到死锁时，让一些进程回滚，让出资源
  * 用银行家算法来检测，如果死锁，则选一个进程回滚。
    * 进程回滚代价大

* **忽略**

  * **PC机由于死锁的影响不大，不易出现死锁，且重启能很好的解决死锁，所以采用忽略的方法应对死锁**

# 内存管理：内存管理概述

## 使用

从内存中分配一段空间，记录其基址，将程序载入这段空间，将基址写到PCB中，在运行过程中对地址进行重定位。

重定位

* 原理：程序中使用相对地址，程序运行时由相对地址+程序基址计算出实际地址
* 时机：运行时重定位
  * 因为程序进入内存后可能被换出再换入，此时的基址可能会改变，所以不能在载入内存时重定位，而要在运行时重定位。

## 分段

程序是分段放入内存中的。

* 每个段都有自己的基址和大小，如果某个段空间不足了，只需要移动这个段，而不需要移动整个程序。

  ![](https://chrishuppor.github.io/image/Snipaste_2020-03-25_17-39-22.png)

* 每个段都有自己的访问属性(读写执行等)

* 每个程序都有自己的段表，即LDT表，用来记录段信息，存储在PCB中。（系统的LDT表叫GDT）

  ![](https://chrishuppor.github.io/image/Snipaste_2020-03-25_18-41-56.png)

## 分区

*(实际系统不采用分区的方式分配内存)*

分区——将内存划分为一个一个的区域，在段请求空间时分配一个区域给它

可变分区——分区大小可变。因为段有大有小，为了提高利用率，所以分区大小根据段来变化。

可变分区管理

* 数据结构——空闲分区表、已分配分区表
* 操作——分配内存，释放内存
* 内存分配算法
  * 首先适配：地址最小的合适分区
    * 速度快
  * 最佳适配：大小不小于申请空间的最小分区
    * 内存碎片多
  * 最差适配：大小不小于申请空间的最大分区
    * 不能保持很大的分区

## 分页

解决分区带来的内存使用效率问题，尤其是内存碎片问题。

**内存分配**：将段分页，将内存也分页，分页大小固定。每次段申请内存时，就将内存以页为单位分配给段(**同一段的页可以分配到不连续的内存页**)。	

**分页大小**：分页的大小，32位操作系统是4K是内存管理的最小单位。

**分配粒度**：表示每次请求内存的时候最小给分配多少，比如32位操作系统基本上每次分配的是64K大小。

**页表**：存放进程的逻辑页与内存的物理页的映射信息，页表指针存在PCB中。

* 重定位：计算段中地址在段中的页号，然后查询页表，找到对应的物理内存页的页号，计算出物理地址。

### 多级页表和快表

* 单页表问题——**页表存储开销**
  * 页的大小和页表的大小存在矛盾：页小有利于提高内存利用率，但是会导致页表变大。 
    * 例如，32位的程序，使用4K的页，可以划分出1M个页面，每个页表项如果需要4个字节，则需要4M的页表，开销太大。所以**页表要小**。

* 解决尝试一：只存放用到的逻辑页
  * 依据：大部分逻辑地址其实都用不到
  * 问题：页表中页号不连续，**不方便查找**。当页较多时带来的查找开销太大。所以**页表一定要连续**。

* **多级页表**——又小又连续的页表

  * 原理

    * 将逻辑地址划分为三部分：页目录(10bit)\页号(10bit)\页内偏移(12bit)

      ![](https://chrishuppor.github.io/image/Snipaste_2020-03-26_11-14-16.png)

      * 页目录表中有1K个表项，页号表中有1K个表项(每个表项大小都是4Byte)。
      * 将页表划分成了页目录和页号表两部分，查询地址时先通过页目录找到对应的页号表，然后从页号表中找到对应的页号，从而获得物理页号，进而在物理页中使用页内偏移找到对应的物理地址。

  * 优点

    * 如果某些逻辑地址用不到，则其对应的页目录表项为空，也就没有对应的页表，从而既保证了**表的连续性**又实现了**只存放用到的逻辑页**。图示如下：

      ![](https://chrishuppor.github.io/image/Snipaste_2020-03-26_11-25-25.png)

  * 问题

    * 增加了一级页表，多访问内存一次。

* **快表**(TLB)——存放常用的页的单级页表，弥补多级页表的访问时间开销。

  * 原理

    * TLB是一组相联快速存储，**是寄存器**

    * 快表不连续，但通过**硬件支持**逻辑页号与页表中存储的全部页号进行比对，一次就可以找到对应的物理页。

      ![](https://chrishuppor.github.io/image/Snipaste_2020-03-26_11-40-58.png)

    * 逻辑地址查找时先到快表中查询，如果命中则直接获得物理地址，否则去多级页表中查询并将页表对应情况添加到快表。

  * 关键——命中率

    ![](https://chrishuppor.github.io/image/Snipaste_2020-03-26_11-51-38.png)

    * TLB越大，命中率越高，但TLB很贵！所以TLB条目在64-1024之间
      * 因为程序地址的访问具有**空间局部性**，通常集中访问某一区域的地址，所以TLB不需要太大。

# 内存管理：虚拟内存——段页结合的实际内存管理

程序适合分段管理，内存适合分页管理

* 程序根据数据内容划分为不同的段，例如数据段、代码段，同一段中的内容具有很强的联系，所以程序适合分段管理。
* 为了提高内存利用率，避免内存碎片，所以将内存分页管理。

段到内存的映射的问题

* 分页模式：如果将段直接映射到内存，则需要将段分页，然后将逻辑页映射到内存页，会导致段在内存中不连续，破坏段的结构。

* 分区模式：保护了段的结构，但可能出现内存碎片的问题，而且操作系统的内存实际使用分页管理。

解决——**虚拟内存**

* 段到虚拟内存的映射使用分区模式(代码区、静态区、常量区、堆区、栈区)，虚拟内存到物理内存的映射使用分页模式。
  * 对于程序来说，认为虚拟内存就是真实的内存空间，自己按照分区的方式被“加载”到虚拟内存中，使用段基址+段偏移的方式寻址。（实际上虚拟内存是不存在的，所谓"加载"只是一种映射，将逻辑地址映射为虚拟地址）
  * 对于物理内存来说，加载的是逻辑地址映射为虚拟地址的程序，地址映射是虚拟地址到物理地址的映射。

虚拟内存机制下的地址映射

* 将逻辑地址转化为 段号+偏移，根据段号找到段基址，段基址加上段内偏移得到虚拟地址
* 将虚拟地址划分为页号+偏移，根据页号找到物理页，映射到物理地址

![](https://chrishuppor.github.io/image/Snipaste_2020-03-26_14-58-43.png)

虚拟内存机制下的程序加载

* 先构造程序段到虚拟内存分区的映射(段表)，在构造虚拟内存到物理内存的映射并将”虚拟内存“(实际是程序段)的数据拷贝到物理内存(页表)。

# 内存管理：物理内存页的换入换出

* 问题
  * 缺页：机器上运行的进程的虚拟内存总和远大于物理内存，必然有些虚拟内存页没有对应的物理内存，也就是缺页。
  * 程序不能缺页：因为虚拟内存将程序与实际内存隔离开，程序认为虚拟内存就是自己独有的“物理内存”，所以”不可能“缺页，即缺页对程序来讲要不可感知。

* 解决办法——换入换出
  * 缺页时将缺少的数据从磁盘换入物理内存，然后修改页表。
  * 换页发生在虚拟内存、物理内存、磁盘之间，程序是感知不到的。

## 换入

* 实现——请求调页(有访问请求，发现缺页时才调页)

  * 程序运行时由MMU负责查页表，每执行一条指令都会检查是否缺页，如果缺页则产生中断，由操作系统负责将缺少的页从磁盘中换入，并修改程序页表。(而程序什么都不知道)

    ![](https://chrishuppor.github.io/image/Snipaste_2020-03-27_10-44-28.png)

* 系统怎么知道磁盘上的哪一页是应该换入的？
  * 使用磁盘缓存换出的页：系统在内存比较小的情况下，会“租用”硬盘的一点空间来模拟内存，这个被租用的内存在硬盘上是一个磁盘文件[pagefile.sys](https://www.baidu.com/s?wd=pagefile.sys&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，也就是所谓的页面文件。
  * 使用页表记录页在磁盘中的地址。

## 换出

* 时机——空闲页不足时

  * 申请空闲页时，如果空闲页不足，则需要将原有的页换出，才有空间将需要的页换入。

* 换出算法——目标：缺页次数少

  * FIFO
    * 问题：可能刚换出的页马上又要用
  * MIN——将之后最远使用的页淘汰（最优方案）
    * 问题：需要知道后续的页使用序列，在实际中是不可能的。
  * LRU——将最近最少使用的页换出(MIN的近似方案)
    * 理论基础：内存访问的空间局部性。所以最近使用的页很可能还要用，最近不用的页则很可能最近不再使用。
    * 实现
      * 时间戳：使用时间戳记录页面最近被使用的时间，换出时选择时间戳最小的页。
        * 问题：每次访问都要修改所有页的时间戳，每次换页都要找到最小值，代价太大
      * 页码栈：每次访问都将当前访问的页换到栈顶，每次换页都将栈底的页换出。
        * 问题：每次访问都要修改栈，代价仍然大
    * 问题：各种实现算法代价大
  * SCR——二次机会法，选择最近没有使用的页换出(LRU近似方案)
    * 实现：将页组织成循环队列，每个页添加一个引用位，访问时由硬件设置为1。选择换出页时遍历页表，将引用位为1的页的引用位设为0，将引用位为0的页换出。
    * 引用位含义：引用位为1表示该页在上次寻找混出页后被访问过，引用位为0则表示该页在上次寻找换出页后没有被访问过。
    * 问题：实际中缺页很少发生，所以上次寻找换出页可能是很久以前了，在这个过程中很可能所有的页都被访问过，则SCR退化成FIFO
  * Clock——改进的SCR
    * 实现：引入一个扫描指针，定时扫描所有页，将引用位清零。*(该算法因为寻找换出页的指针和扫描指针一快一慢，像clock而得名)*

* 物理页分配数量

  * 可以通过算法(如工作集)获得程序集中使用访问的页的个数，然后作为分配数量（略）

  ![](https://chrishuppor.github.io/image/Snipaste_2020-03-27_12-17-07.png)

# IO管理

IO也是计算机工作的一个重要组成部分，但是讲起来内容就比较少了。

IO设备工作流程：CPU给设备控制器发送指令=>设备控制器驱动设备运转，完成后向CPU发中断=>CPU处理中断，将数据加载到内存。

![](https://chrishuppor.github.io/image/Snipaste_2020-03-27_15-33-43.png)

在linux系统中将一切看做文件，因此，操作设备实际上也是操作文件(/dev/XXX)。具体如下：

1. 在系统启动时，创建了shell进程，并在shell进程中初始化了各个设备文件。

   ![](https://chrishuppor.github.io/image/Snipaste_2020-03-27_15-42-36.png)

   在初始化的时候获取文件元信息，将文件信息指针添加到PCB中，最终建立如下的链：

   ![](https://chrishuppor.github.io/image/Snipaste_2020-03-27_15-50-27.png)

   linux新进程都是父进程fork来的，所以创建出的新进程的PCB中也有设备文件数组。***(究竟fork时发生了什么)***

2. 进程通过库函数调用系统调用，然后系统调用从当前进程的PCB中找到对应的设备文件进行操作（这里说的简单，实际对设备文件的操作也是一层层代码，比较复杂）。

   如果是输出设备，到这里就结束了。如果是输入设备，还需要后续的步骤。

3. 设备控制器从设备接收输入数据并存储，完成后，发送中断给CPU
4. CPU调用中断处理程序，处理输入数据。

显示器和键盘操作示意图：

![](https://chrishuppor.github.io/image/Snipaste_2020-03-27_16-46-32.png)

## 磁盘管理

磁盘本质是一种IO设备，所以操作的核心流程和其他设备一样，但是在实现上要更加复杂。

磁盘结构如下：

![](https://chrishuppor.github.io/image/Snipaste_2020-03-27_16-53-35.png)

读写磁盘：移动磁头到目标磁道(寻道)=>磁盘旋转，使磁头落到目标扇区(旋转)=>磁生电、电生磁进行读写

读写磁盘需要的参数：柱面(哪个磁道)、磁头(哪个盘片)、扇区、缓冲位置(内存数据的地址)

(未完...)

