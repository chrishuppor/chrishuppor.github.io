---
layout: post
title: "c++内存泄漏问题"
date: 2019-11-15 9:16:18
categories: Program
tags: Windows cpp
---

c++内存泄漏的原因、检测和解决办法。

# 原因

* 直接原因——**程序未能释放掉不再使用的内存，同时失去了对该段内存的控制**
* 根本原因——c++没有垃圾回收机制
* 分类
  * 堆内存泄漏
    - 使用malloc\realloc\new手动分配的一块内存，需要使用对应的free\delete手动释放。如果没有释放，这时这块内存就会常驻内存，造成堆内存泄漏
  * 系统资源泄漏
    - 分配给程序使用的资源没有使用相应函数释放，如bitmap\handle\socket.

# 检测

* 查看有没有内存泄漏的方式
  * 查看程序运行时的内存和句柄
    * 运行procexploer，查看对应进程的属性->performance中的virtual memory和handle，如果有一直增加的问题就极大可能有泄漏问题：
      - virtual memory：申请了内存但用完没释放，最后导致内存用光；
      - handle：创建了句柄但没有释放句柄。windows允许程序拥有的句柄数量有上限，如果超过了这个上限就会有问题。
  * 使用内存泄漏检测及泄漏定位工具
    * linux下可以使用valgrinds
    * VC++可以使用BoundsChecker、purify、Visual Leak Detector等工具和vc++提供的函数

## vc++提供的函数内存泄漏检测函数

* 头文件：<crtdbg.h>  

* 检测函数：_CrtDumpMemoryLeaks()—在”输出-调试“中打印内存泄漏报告

* 定位函数：_CrtSetBreakAlloc(int)—参数是内存申请号，设置了内存断点，在申请这一个内存时中断。

* 泄漏代码定位方法
  * 调用检测函数得到泄漏的内存申请号
  * 调用定位函数，设置内存断点，在申请该内存时中断
  * 程序中断后，通过查看运行时函数调用堆栈找到用户空间的代码，综合分析内存泄漏的原因，排除内存泄漏。

## 注意事项

* _CrtDumpMemoryLeaks函数只能显示出内存泄漏的地址和内存编号，所以只有当程序始终按一个顺序申请内存时，才能用\_CrtSetBreakAlloc定位到泄漏位置。
* 需要程序是debug模式——使用MTd或MDd
* 要求程序自然退出，也就是说不能是中断调试或强行关闭的。

* 可以添加如下代码

```c
#ifdef _DEBUG
#define new   new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif
```

## 使用示例

### 检测

内存泄漏检测：

```c
#include <crtdbg.h>  

#ifdef _DEBUG
#define new   new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif
int main()
{
	byte *tmp = new byte[100];//内存泄漏代码
	_CrtDumpMemoryLeaks();
}
```

输出内容如下：

```
{117} normal block at 0x0073AD30, 100 bytes long.
 Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 
```

### 定位

在代码中添加_CrtSetBreakAlloc(117)，117就是要中断的内存号。

```c
#include <crtdbg.h>  

#ifdef _DEBUG
#define new   new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif
int main()
{
	_CrtSetBreakAlloc(117); //添加
	byte *tmp = new byte[100];
	_CrtDumpMemoryLeaks();
}
```

然后程序就会在第117次申请内存时断掉：

![图1 断点示例图](https://chrishuppor.github.io/image/Snipaste_2019-11-14_15-31-59.png)

# 解决方法

1. 优化设计，养成良好的编程习惯
2. 使用智能指针（c++提供的指针类型，可以自己管理内存的释放）

# 参考文章

1[单元测试工具Numega](http://www.cnitblog.com/qiuyangzh/archive/2005/07/14/975.html) (包含BoundsChecker的使用)

2 [C++内存泄露及处理方法](https://blog.csdn.net/guoxiaoqian8028/article/details/18324131?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)