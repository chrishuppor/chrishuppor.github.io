---
layout: post
title: "IAT表修复"
date: 2019-10-28 8:8:8
categories: Reverse
tags: Unpack
---

脱壳第二步，IAT表修复。

# IAT表修复

* dump下来的数据中，IAT表中的地址已经填充过了，需要恢复成未加载的PE的IAT的样子，即将函数地址修改为存在Name表中的API名称的RVA。

* 壳可能对原始程序的IAT表进行了重定位，即不再存放API地址，而是存放另外一个地址，然后通过这个地址调用API。

## 普通修复

1. 找到IAT表起始地址
2. 计算IAT表大小
3. 使用REC或Scylla等工具修复dump文件

具体操作如下：

1. 找IAT
   1. 找到OEP后，右键查看所有的互调调用

      ![图1 查看互用调用](https://chrishuppor.github.io/image/Snipaste_2020-03-25_23-24-28.png)

   2. 选择一个间接调用，查看其内存地址，如果在落在dll模块地址范围中，则说明这可能就是IAT的位置。

      ![图2 间接调用示例](https://chrishuppor.github.io/image/Snipaste_2020-03-25_23-25-11.png)

      ![图3 转到dump查看](https://chrishuppor.github.io/image/Snipaste_2020-03-25_23-25-45.png)

2. IAT中使用数组的结构记录导入函数地址，每个模块以0x00000000结束。如图，很容易判断0x1106000就是IAT起始地址，0x110612b就是IAT结束地址，所以IAT大小为0x12c

   起始：

   ![图4 IAT起始](https://chrishuppor.github.io/image/Snipaste_2020-03-25_23-27-21.png)

   结束：

   ![图5 IAT结束](https://chrishuppor.github.io/image/Snipaste_2020-03-25_23-29-29.png)

3. 打开修复工具，附加到已运行到OEP的进程，填好OEP、IAT VA、IAT size，点击按钮获取IAT

   ![图6 scylla界面](https://chrishuppor.github.io/image/Snipaste_2020-03-25_23-30-07.png)

4. 修复转储文件。

## 重定位修复

首先按照普通修复的方式，获取IAT表，然后工具会显示出有一些无效项，这些可能就是重定位过的那部分IAT。

![图7 无效IAT函数](https://chrishuppor.github.io/image/Snipaste_2020-03-25_23-30-44.png)

### 手工修复

1. 追到程序里看这个地址对应的API是什么

2. 在工具里选择对应的API就可以了（然后反复操作几十次、几百次...）

   结果如下

   ![图7 手工修复效果](https://chrishuppor.github.io/image/Snipaste_2020-03-25_23-31-55.png)

### 工具修复

* 前辈们针对一些壳开发了很多工具，可以搜出来用用(针对性太强，换个壳就凉了)
* REC或Scylla等工具自带了一些重定位修复插件(经常不靠谱)

### 爆破修复

追踪到壳程序的重定位代码，爆破掉。

* 因为程序无论如何都需要获取并存储API地址的，所以要么将重定位的地址修改为API的地址写入IAT中，要么将API地址的存储地址修改为IAT地址。
* 有些壳只是重定位了一部分IAT，所以必然对是否进行重定位有分支判断(条件跳转)，所以找到它并改为jmp。
	* 可以通过给存储重定位地址的地址下硬件断点，然后重启程序，就会断在写重定位的位置。

